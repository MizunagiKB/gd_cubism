<?xml version="1.0" encoding="UTF-8" ?>
<class name="GDCubismUserModel" inherits="SubViewport" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
		This is a [SubViewport] subclass for loading the Live2D model, generating the [Texture] necessary for display, and performing operations.
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="advance">
			<return type="void" />
			<param index="0" name="delta" type="float" />
			<description>
				Advances the animation by the specified [i]delta[/i] time (in seconds).
				Please specify a value of 0.0 or more for delta.
			</description>
		</method>
		<method name="csm_get_latest_moc_version">
			<return type="int" enum="GDCubismUserModel.moc3FileFormatVersion" />
			<description>
				Returns the latest file version that [GDCubismUserModel] can load.
			</description>
		</method>
		<method name="csm_get_moc_version">
			<return type="int" enum="GDCubismUserModel.moc3FileFormatVersion" />
			<description>
				Returns the version of the loaded [b]moc3[/b] file.
			</description>
		</method>
		<method name="csm_get_version">
			<return type="Dictionary" />
			<description>
				Returns the version number of Cubism Native SDK Core used by GDCubism in [Dictionary] format.
				- [int] [b]version:[/b] The value returned by the [i]csmVersion[/i] function is stored as is.
				- [int] [b]major:[/b] Only the major version is extracted from version and stored.
				- [int] [b]minor:[/b] Only the minor version is extracted from version and stored.
				- [int] [b]patch:[/b] Only the patch number is extracted from version and stored.
			</description>
		</method>
		<method name="get_canvas_info" qualifiers="const">
			<return type="Dictionary" />
			<description>
				Returns the following information in [Dictionary] format.
				- [Vector2] [b]size_in_pixels:[/b] Returns the width and height of the canvas of the loaded Live2D model in pixels.
				- [Vector2] [b]origin_in_pixels:[/b] Returns the center position of the loaded Live2D model in pixels.
				- [float] [b]pixels_per_unit:[/b] Returns the [i]pixelsPerUnit[/i] of the loaded Live2D model.
			</description>
		</method>
		<method name="get_cubism_motion_queue_entries" qualifiers="const">
			<return type="Array" />
			<description>
				Returns information about the currently playing [i]Motion[/i].
			</description>
		</method>
		<method name="get_expressions" qualifiers="const">
			<return type="Array" />
			<description>
				Returns a list of [i]Expressions[/i] from the currently held Live2D model.
				The information obtained can be used as an argument for the [method GDCubismUserModel.start_expression] function.
			</description>
		</method>
		<method name="get_hit_areas" qualifiers="const">
			<return type="Array" />
			<description>
				Gets information about [i]HitArea[/i] set in Live2D model.
			The elements of array are [Dictionary], and have elements id and name.
			id points to mesh element, so it can be used as a key for [method GDCubismUserModel.get_meshes].

			You can implement interaction with Live2D model using this function and information obtained from [method GDCubismUserModel.get_meshes].
			If you don't need advanced processing, you can easily use it by using [GDCubismEffectHitArea] class.
			</description>
		</method>
		<method name="get_meshes" qualifiers="const">
			<return type="Dictionary" />
			<description>
				Gets information about [ArrayMesh] of [MeshInstance] used in current Motion state.
				The keys this [Dictionary] holds are identical to names of [MeshInstance] generated by [GDCubismUserModel]. The information that can be obtained is internal [ArrayMesh].
				It can be used in following way.
				[b]Example:[/b]
				[codeblocks]
				[gdscript]
				var dict_mesh: Dictionary = model.get_meshes()
				var ary_mesh: ArrayMesh = dict_mesh[art_mesh_name]
				var ary_surface: Array = ary_mesh.surface_get_arrays(0)

				var mesh_vertex: PackedVector2Array = ary_surface[ArrayMesh.ARRAY_VERTEX]
				var mesh_tex_uv: PackedVector2Array = ary_surface[ArrayMesh.ARRAY_TEX_UV]
				var mesh_index: PackedInt32Array = ary_surface[ArrayMesh.ARRAY_INDEX]
				[/gdscript]
				[/codeblocks]
				[b]CAUTION[/b] get_meshes is an experimental function added in v0.1. Please note that the specification may change or be deleted in the future.
			</description>
		</method>
		<method name="get_motions" qualifiers="const">
			<return type="Dictionary" />
			<description>
				Returns a list of _Motions_ from the currently held Live2D model.
				The returned _Dictionary_ is _group_ and the number of motions contained in it.
				To enumerate all motions, write as follows.
				[b]Example:[/b]
				[codeblocks]
				[gdscript]
				var dict_motion = $GDCubismUserModel.get_motions()
				for group in dict_motion.keys():
				    for no in dict_motion[group]:
				        print("group: %s, no: %d" % [group, no])
				[/gdscript]
				[/codeblocks]
			</description>
		</method>
		<method name="get_parameters" qualifiers="const">
			<return type="Array" />
			<description>
				Gets a class to operate the currently held Live2D model.
			</description>
		</method>
		<method name="get_part_opacities" qualifiers="const">
			<return type="Array" />
			<description>
				Gets a class to operate the part transparency of the currently held Live2D model.
			</description>
		</method>
		<method name="start_expression">
			<return type="void" />
			<param index="0" name="expression_id" type="String" />
			<description>
				Plays the specified [param expression_id].
			</description>
		</method>
		<method name="start_motion">
			<return type="GDCubismMotionQueueEntryHandle" />
			<param index="0" name="group" type="String" />
			<param index="1" name="no" type="int" />
			<param index="2" name="priority" type="int" enum="GDCubismUserModel.Priority" />
			<description>
				Plays the [i]Motion[/i] specified by [param group] and [param no].
			</description>
		</method>
		<method name="start_motion_loop">
			<return type="GDCubismMotionQueueEntryHandle" />
			<param index="0" name="group" type="String" />
			<param index="1" name="no" type="int" />
			<param index="2" name="priority" type="int" enum="GDCubismUserModel.Priority" />
			<param index="3" name="loop" type="bool" />
			<param index="4" name="loop_fade_in" type="bool" />
			<description>
				Plays the [i]Motion[/i] specified by [param group] and [param no].
				Specify this when you want to play repeatedly. If the [param loop] argument is [code]false[/code], it behaves the same as the [method GDCubismUserModel.start_motion] function.
			</description>
		</method>
		<method name="stop_expression">
			<return type="void" />
			<description>
				Stops the currently playing [i]Expression[/i].
			</description>
		</method>
		<method name="stop_motion">
			<return type="void" />
			<description>
				Stops the currently playing [i]Motion[/i].
			</description>
		</method>
	</methods>
	<members>
		<member name="assets" type="String" setter="set_assets" getter="get_assets" default="&quot;&quot;">
			By specifying a file with the [code]*.model3.json[/code] extension, you can load the Live2D model. As soon as you specify a file, it will be loaded immediately.
			if you want to switch the Live2D model, you can do so by simply specifying a new file.
		</member>
		<member name="load_expressions" type="bool" setter="set_load_expressions" getter="get_load_expressions" default="true">
			If set to [code]false[/code], it will not load [i]Expressions[/i] when loading the Live2D Model.
		</member>
		<member name="load_motions" type="bool" setter="set_load_motions" getter="get_load_motions" default="true">
			If set to [code]false[/code], it will not load [i]Motions[/i] when loading the Live2D Model.
		</member>
		<member name="mask_viewport_size" type="int" setter="set_mask_viewport_size" getter="get_mask_viewport_size" default="0">
			Specify the maximum resolution for any individual mask required for the Live2D model.
		If set to 0, size of the mask will be relative to the source pixel resolution of the model's canvas.
		Mask resolution is also dynamically resized relative to the model's scale within its viewport.

		Reducing the resolution can help conserve GPU memory, however reducing resolution too far can cause visual issues where masks are applied.
		For many, it's best to leave this at default and rely solely on the automatic scaling.
		</member>
		<member name="parameter_mode" type="int" setter="set_parameter_mode" getter="get_parameter_mode" enum="GDCubismUserModel.ParameterMode" default="0">
			Specifies the control method for the currently held Live2D model.
		</member>
		<member name="physics_evaluate" type="int" setter="set_physics_evaluate" getter="get_physics_evaluate" enum="GDCubismUserModel.PhysicsEvaluate" default="true">
			Setting this parameter to [code]false[/code] disables physical calculations.
		</member>
		<member name="playback_process_mode" type="int" setter="set_process_callback" getter="get_process_callback" enum="GDCubismUserModel.MotionProcessCallback" default="1">
			Specifies the playback method for the currently held Live2D model.
		</member>
		<member name="pose_update" type="int" setter="set_pose_update" getter="get_pose_update" enum="GDCubismUserModel.PoseUpdate" default="true">
			Setting this parameter to [code]false[/code] disables transparency calculations between drawing parts specified in the pose group.
			If you want to manually handle all transparency calculations, set this parameter to [code]false[/code].
		</member>
		<member name="shader_add" type="Shader" setter="set_shader_add" getter="get_shader_add">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = (color_tex.rgb + color_screen.rgb) - (color_tex.rgb * color_screen.rgb);
			    vec4 color = color_tex * color_base;
			    COLOR = vec4(color.rgb * color.a, 0.0);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask" type="Shader" setter="set_shader_mask" getter="get_shader_mask">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_mix, unshaded;

			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    COLOR = channel * texture(tex_main, UV).a;
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_add" type="Shader" setter="set_shader_mask_add" getter="get_shader_mask_add">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask.rgb = color_for_mask.rgb * mask_val;
			    COLOR = vec4(color_for_mask.rgb, 0.0);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_add_inv" type="Shader" setter="set_shader_mask_add_inv" getter="get_shader_mask_add_inv">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha    
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask.rgb = color_for_mask.rgb * (1.0 - mask_val);
			    COLOR = vec4(color_for_mask.rgb, 0.0);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_mix" type="Shader" setter="set_shader_mask_mix" getter="get_shader_mask_mix">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask = color_for_mask * mask_val;
			    COLOR = color_for_mask;
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_mix_inv" type="Shader" setter="set_shader_mask_mix_inv" getter="get_shader_mask_mix_inv">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha    
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask = color_for_mask * (1.0 - mask_val);
			    COLOR = color_for_mask;
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_mul" type="Shader" setter="set_shader_mask_mul" getter="get_shader_mask_mul">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_mul, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask = color_for_mask * mask_val;
			    COLOR = vec4(
			        color_for_mask.r + (1.0 - color_for_mask.a),
			        color_for_mask.g + (1.0 - color_for_mask.a),
			        color_for_mask.b + (1.0 - color_for_mask.a),
			        1.0
			    );
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_mul_inv" type="Shader" setter="set_shader_mask_mul_inv" getter="get_shader_mask_mul_inv">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_mul, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha    
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask = color_for_mask * (1.0 - mask_val);
			    COLOR = vec4(
			        color_for_mask.r + (1.0 - color_for_mask.a),
			        color_for_mask.g + (1.0 - color_for_mask.a),
			        color_for_mask.b + (1.0 - color_for_mask.a),
			        1.0
			    );
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mix" type="Shader" setter="set_shader_mix" getter="get_shader_mix">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = (color_tex.rgb + color_screen.rgb) - (color_tex.rgb * color_screen.rgb);
			    vec4 color = color_tex * color_base;
			    COLOR = vec4(color.rgb * color.a, color.a);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mul" type="Shader" setter="set_shader_mul" getter="get_shader_mul">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = (color_tex.rgb + color_screen.rgb) - (color_tex.rgb * color_screen.rgb);
			    vec4 color = color_tex * color_base;
			    COLOR = vec4(color.rgb * color.a, color.a);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="speed_scale" type="float" setter="set_speed_scale" getter="get_speed_scale" default="1.0">
			Specifies the playback speed of the currently held Live2D model.
		</member>
	</members>
	<signals>
		<signal name="motion_event">
			<param index="0" name="value" type="String" />
			<description>
				Called at the timing of the event time embedded in [i]Motion[/i].
				[b]Example:[/b]
				[codeblocks]
				[gdscript]
				func _on_motion_event(value: String):
				    print(value)

				func _ready():
				    $GDCubismUserModel.motion_event.connect(_on_motion_event)
				[/gdscript]
				[/codeblocks]
			</description>
		</signal>
		<signal name="motion_finished">
			<description>
				Called at the timing when _Motion_ has finished playing.
				[b]Example:[/b]
				[codeblocks]
				[gdscript]
					func _on_motion_finished(value: String):
					    print(value)

					func _ready():
					    $GDCubismUserModel.motion_event.connect(_on_motion_event)
				[/gdscript]
				[/codeblocks]
			</description>
		</signal>
	</signals>
	<constants>
		<constant name="CSM_MOC_VERSION_UNKNOWN" value="0" enum="moc3FileFormatVersion">
			Unknown or failed to load
		</constant>
		<constant name="CSM_MOC_VERSION_30" value="1" enum="moc3FileFormatVersion">
			moc3 file version from 3.0.00 to 3.2.07
		</constant>
		<constant name="CSM_MOC_VERSION_33" value="2" enum="moc3FileFormatVersion">
			moc3 file version from 3.3.00 to 3.3.03
		</constant>
		<constant name="CSM_MOC_VERSION_40" value="3" enum="moc3FileFormatVersion">
			moc3 file version from 4.0.00 to 4.1.05
		</constant>
		<constant name="CSM_MOC_VERSION_42" value="4" enum="moc3FileFormatVersion">
			moc3 file version from 4.2.00 to 4.2.02
		</constant>
		<constant name="CSM_MOC_VERSION_50" value="5" enum="moc3FileFormatVersion">
			moc3 file version 5.0.00 and above
		</constant>
		<constant name="PRIORITY_NONE" value="0" enum="Priority">
		</constant>
		<constant name="PRIORITY_IDLE" value="1" enum="Priority">
		</constant>
		<constant name="PRIORITY_NORMAL" value="2" enum="Priority">
		</constant>
		<constant name="PRIORITY_FORCE" value="3" enum="Priority">
		</constant>
		<constant name="FULL_PARAMETER" value="0" enum="ParameterMode">
			Specify this when playing the [i]Motion[/i] specified by the [method GDCubismUserModel.start_motion] function.
			When this is specified, operations by [GDCubismParameter] cannot be performed.
		</constant>
		<constant name="NONE_PARAMETER" value="1" enum="ParameterMode">
			Specify this when using the [GDCubismParameter] obtained by the [method GDCubismUserModel.get_parameters] function to operate the Live2D model.
			When this is specified, motion playback cannot be performed by the [method GDCubismUserModel.start_motion] function.
		</constant>
		<constant name="PHYSICS" value="0" enum="MotionProcessCallback">
			The animation update process is performed within the [code]_physics_process[/code] function.
			Use this when you want to interact with physical simulation.
		</constant>
		<constant name="IDLE" value="1" enum="MotionProcessCallback">
			The animation update process is performed within the [code]_process[/code] function.
		</constant>
		<constant name="MANUAL" value="2" enum="MotionProcessCallback">
			No animation update process is performed. To process the animation, use the [method GDCubismUserModel.advance] function.
			I hope this helps! If you have any other requests, feel free to ask.
		</constant>
	</constants>
</class>
