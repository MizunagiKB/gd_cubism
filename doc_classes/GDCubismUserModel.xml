<?xml version="1.0" encoding="UTF-8" ?>
<class name="GDCubismUserModel" inherits="SubViewport" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/godotengine/godot/master/doc/class.xsd">
	<brief_description>
	</brief_description>
	<description>
		This is a [SubViewport] subclass for loading the Live2D model, generating the [Texture] necessary for display, and performing operations.
	</description>
	<tutorials>
	</tutorials>
	<methods>
		<method name="advance">
			<return type="void" />
			<param index="0" name="delta" type="float" />
			<description>
				Advances the animation by the specified [i]delta[/i] time (in seconds).
				Please specify a value of 0.0 or more for delta.
			</description>
		</method>
		<method name="clear">
			<return type="void" />
			<description>
				Destroys the currently held Live2D model.
			</description>
		</method>
		<method name="csm_get_latest_moc_version">
			<return type="int" enum="GDCubismUserModel.moc3FileFormatVersion" />
			<description>
				Returns the latest file version that [GDCubismUserModel] can load.
			</description>
		</method>
		<method name="csm_get_moc_version">
			<return type="int" enum="GDCubismUserModel.moc3FileFormatVersion" />
			<description>
				Returns the version of the loaded [b]moc3[/b] file.
			</description>
		</method>
		<method name="csm_get_version">
			<return type="Dictionary" />
			<description>
				Returns the version number of Cubism Native SDK Core used by GDCubism in [Dictionary] format.
				- [int] [b]version:[/b] The value returned by the [i]csmVersion[/i] function is stored as is.
				- [int] [b]major:[/b] Only the major version is extracted from version and stored.
				- [int] [b]minor:[/b] Only the minor version is extracted from version and stored.
				- [int] [b]patch:[/b] Only the patch number is extracted from version and stored.
			</description>
		</method>
		<method name="get_canvas_info" qualifiers="const">
			<return type="Dictionary" />
			<description>
				Returns the following information in [Dictionary] format.
				- [Vector2] [b]size_in_pixels:[/b] Returns the width and height of the canvas of the loaded Live2D model in pixels.
				- [Vector2] [b]origin_in_pixels:[/b] Returns the center position of the loaded Live2D model in pixels.
				- [float] [b]pixels_per_unit:[/b] Returns the [i]pixelsPerUnit[/i] of the loaded Live2D model.
			</description>
		</method>
		<method name="get_cubism_motion_queue_entries" qualifiers="const">
			<return type="Array" />
			<description>
				Returns information about the currently playing [i]Motion[/i].
			</description>
		</method>
		<method name="get_expressions" qualifiers="const">
			<return type="Array" />
			<description>
				Returns a list of [i]Expressions[/i] from the currently held Live2D model.
				The information obtained can be used as an argument for the [method GDCubismUserModel.start_expression] function.
			</description>
		</method>
		<method name="get_hit_areas" qualifiers="const">
			<return type="Array" />
			<description>
			Gets information about [i]HitArea[/i] set in Live2D model.
			The elements of array are [Dictionary], and have elements id and name.
			id points to mesh element, so it can be used as a key for [method GDCubismUserModel.get_meshes].
			
			You can implement interaction with Live2D model using this function and information obtained from [method GDCubismUserModel.get_meshes].
			If you don't need advanced processing, you can easily use it by using [GDCubismEffectHitArea] class.
			</description>
		</method>
		<method name="get_meshes" qualifiers="const">
			<return type="Dictionary" />
			<description>
				Gets information about [ArrayMesh] of [MeshInstance] used in current Motion state.
				The keys this [Dictionary] holds are identical to names of [MeshInstance] generated by [GDCubismUserModel]. The information that can be obtained is internal [ArrayMesh].
				It can be used in following way.
				[b]Example:[/b]
				[codeblocks]
				[gdscript]
				var dict_mesh: Dictionary = model.get_meshes()
				var ary_mesh: ArrayMesh = dict_mesh[art_mesh_name]
				var ary_surface: Array = ary_mesh.surface_get_arrays(0)

				var mesh_vertex: PackedVector2Array = ary_surface[ArrayMesh.ARRAY_VERTEX]
				var mesh_tex_uv: PackedVector2Array = ary_surface[ArrayMesh.ARRAY_TEX_UV]
				var mesh_index: PackedInt32Array = ary_surface[ArrayMesh.ARRAY_INDEX]
				[/gdscript]
				[/codeblocks]
				[b]CAUTION[/b] get_meshes is an experimental function added in v0.1. Please note that the specification may change or be deleted in the future.
			</description>
		</method>
		<method name="get_motions" qualifiers="const">
			<return type="Dictionary" />
			<description>
				Returns a list of _Motions_ from the currently held Live2D model.
				The returned _Dictionary_ is _group_ and the number of motions contained in it.
				To enumerate all motions, write as follows.
				[b]Example:[/b]
				[codeblocks]
				[gdscript]
				var dict_motion = $GDCubismUserModel.get_motions()
				for group in dict_motion.keys():
				    for no in dict_motion[group]:
				        print("group: %s, no: %d" % [group, no])
				[/gdscript]
				[/codeblocks]
			</description>
		</method>
		<method name="get_parameters" qualifiers="const">
			<return type="Array" />
			<description>
				Gets a class to operate the currently held Live2D model.
			</description>
		</method>
		<method name="get_part_opacities" qualifiers="const">
			<return type="Array" />
			<description>
				Gets a class to operate the part transparency of the currently held Live2D model.
			</description>
		</method>
		<method name="start_expression">
			<return type="void" />
			<param index="0" name="expression_id" type="String" />
			<description>
				Plays the specified [param expression_id].
			</description>
		</method>
		<method name="start_motion">
			<return type="GDCubismMotionQueueEntryHandle" />
			<param index="0" name="group" type="String" />
			<param index="1" name="no" type="int" />
			<param index="2" name="priority" type="int" enum="GDCubismUserModel.Priority" />
			<description>
				Plays the [i]Motion[/i] specified by [param group] and [param no].
			</description>
		</method>
		<method name="start_motion_loop">
			<return type="GDCubismMotionQueueEntryHandle" />
			<param index="0" name="group" type="String" />
			<param index="1" name="no" type="int" />
			<param index="2" name="priority" type="int" enum="GDCubismUserModel.Priority" />
			<param index="3" name="loop" type="bool" />
			<param index="4" name="loop_fade_in" type="bool" />
			<description>
				Plays the [i]Motion[/i] specified by [param group] and [param no].
				Specify this when you want to play repeatedly. If the [param loop] argument is [code]false[/code], it behaves the same as the [method GDCubismUserModel.start_motion] function.
			</description>
		</method>
		<method name="stop_expression">
			<return type="void" />
			<description>
				Stops the currently playing [i]Expression[/i].
			</description>
		</method>
		<method name="stop_motion">
			<return type="void" />
			<description>
				Stops the currently playing [i]Motion[/i].
			</description>
		</method>
	</methods>
	<members>
		<member name="adjust_position" type="Vector2" setter="set_adjust_position" getter="get_adjust_position" default="Vector2(0, 0)">
			Changes the rendering position of the Live2D model.
			GDCubism performs the rendering of the Live2D model within its own SubViewport.
			By adjusting this parameter, you can close-up a part of the Live2D model or use it when the auto_scale rendered result is not drawn well.
		</member>
		<member name="adjust_scale" type="float" setter="set_adjust_scale" getter="get_adjust_scale" default="1.0">
			Changes the rendering size of the Live2D model.
			GDCubism performs the rendering of the Live2D model within its own [SubViewport].
			By adjusting this parameter, you can freely change the rendering size of the Live2D model.
		</member>
		<member name="assets" type="String" setter="set_assets" getter="get_assets" default="&quot;&quot;">
			By specifying a file with the [code]*.model3.json[/code] extension, you can load the Live2D model. As soon as you specify a file, it will be loaded immediately.
			Since the [method GDCubismUserModel.clear] function is called internally, if you want to switch the Live2D model, you can do so by simply specifying a new file.
		</member>
		<member name="auto_scale" type="bool" setter="set_auto_scale" getter="get_auto_scale" default="true">
			[GDCubismUserModel] tries to render the Live2D model to fit within the [SubViewport] size specified for itself. Therefore, there may be results that the creator of the Live2D model did not intend.
			By unchecking this, you can display without scaling.
		</member>
		<member name="load_expressions" type="bool" setter="set_load_expressions" getter="get_load_expressions" default="true">
			If set to [code]false[/code], it will not load [i]Expressions[/i] when loading the Live2D Model.
		</member>
		<member name="load_motions" type="bool" setter="set_load_motions" getter="get_load_motions" default="true">
			If set to [code]false[/code], it will not load [i]Motions[/i] when loading the Live2D Model.
		</member>
		<member name="mask_viewport_size" type="Vector2i" setter="set_mask_viewport_size" getter="get_mask_viewport_size" default="Vector2i(0, 0)">
		Specify the resolution for the mask image required for the Live2D model.
		If either x or y is set to 0, the same size as the Viewport set in [GDCubismUserModel] will be used.

		Reducing the resolution can help conserve GPU memory.
		However, if the size is reduced to less than approximately 512x512, there may be issues with rendering quality depending on where the mask is applied.
		Ensure that the aspect ratio of this image matches the aspect ratio of the Viewport in [GDCubismUserModel]. For example, if it is _1024x512_, then values like _512x256_ or _128x64_ are appropriate.

		Since GDCubism assumes the same aspect ratio as the Viewport for rendering, using an incorrect ratio may result in undesirable outcomes.
		</member>
		<member name="parameter_mode" type="int" setter="set_parameter_mode" getter="get_parameter_mode" enum="GDCubismUserModel.ParameterMode" default="0">
			Specifies the control method for the currently held Live2D model.
		</member>
		<member name="playback_process_mode" type="int" setter="set_process_callback" getter="get_process_callback" enum="GDCubismUserModel.MotionProcessCallback" default="1">
			Specifies the playback method for the currently held Live2D model.
		</member>
		<member name="shader_add" type="Shader" setter="set_shader_add" getter="get_shader_add">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = (color_tex.rgb + color_screen.rgb) - (color_tex.rgb * color_screen.rgb);
			    vec4 color = color_tex * color_base;
			    COLOR = vec4(color.rgb * color.a, 0.0);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask" type="Shader" setter="set_shader_mask" getter="get_shader_mask">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_mix, unshaded;

			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    COLOR = channel * texture(tex_main, UV).a;
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_add" type="Shader" setter="set_shader_mask_add" getter="get_shader_mask_add">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask.rgb = color_for_mask.rgb * mask_val;
			    COLOR = vec4(color_for_mask.rgb, 0.0);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_add_inv" type="Shader" setter="set_shader_mask_add_inv" getter="get_shader_mask_add_inv">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha    
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask.rgb = color_for_mask.rgb * (1.0 - mask_val);
			    COLOR = vec4(color_for_mask.rgb, 0.0);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_mix" type="Shader" setter="set_shader_mask_mix" getter="get_shader_mask_mix">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask = color_for_mask * mask_val;
			    COLOR = color_for_mask;
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_mix_inv" type="Shader" setter="set_shader_mask_mix_inv" getter="get_shader_mask_mix_inv">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;
				
			    // premul alpha    
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask = color_for_mask * (1.0 - mask_val);
			    COLOR = color_for_mask;
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_mul" type="Shader" setter="set_shader_mask_mul" getter="get_shader_mask_mul">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_mul, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask = color_for_mask * mask_val;
			    COLOR = vec4(
			        color_for_mask.r + (1.0 - color_for_mask.a),
			        color_for_mask.g + (1.0 - color_for_mask.a),
			        color_for_mask.b + (1.0 - color_for_mask.a),
			        1.0
			    );
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mask_mul_inv" type="Shader" setter="set_shader_mask_mul_inv" getter="get_shader_mask_mul_inv">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_mul, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;
			uniform sampler2D tex_mask : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;
				
			    // premul alpha    
			    color_tex.rgb = color_tex.rgb + color_screen.rgb - (color_tex.rgb * color_screen.rgb);
			    vec4 color_for_mask = color_tex * color_base;
			    color_for_mask.rgb = color_for_mask.rgb * color_for_mask.a;

			    vec4 clip_mask = texture(tex_mask, SCREEN_UV) * channel;
			    float mask_val = clip_mask.r + clip_mask.g + clip_mask.b + clip_mask.a;
			    color_for_mask = color_for_mask * (1.0 - mask_val);
			    COLOR = vec4(
			        color_for_mask.r + (1.0 - color_for_mask.a),
			        color_for_mask.g + (1.0 - color_for_mask.a),
			        color_for_mask.b + (1.0 - color_for_mask.a),
			        1.0
			    );
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mix" type="Shader" setter="set_shader_mix" getter="get_shader_mix">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = (color_tex.rgb + color_screen.rgb) - (color_tex.rgb * color_screen.rgb);
			    vec4 color = color_tex * color_base;
			    COLOR = vec4(color.rgb * color.a, color.a);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="shader_mul" type="Shader" setter="set_shader_mul" getter="get_shader_mul">
			Specifies the [i]shader[/i] used to render the Live2D model.
			By default, the following [i]shader[/i] is used.
			[codeblocks]
			[gdscript]
			shader_type canvas_item;
			render_mode blend_premul_alpha, unshaded;

			uniform vec4 color_base;
			uniform vec4 color_screen;
			uniform vec4 color_multiply;
			uniform vec4 channel;
			uniform sampler2D tex_main : filter_linear_mipmap;

			void vertex() {
			    UV.y = 1.0 - UV.y;
			}

			void fragment() {
			    vec4 color_tex = texture(tex_main, UV);
			    color_tex.rgb = color_tex.rgb * color_multiply.rgb;

			    // premul alpha
			    color_tex.rgb = (color_tex.rgb + color_screen.rgb) - (color_tex.rgb * color_screen.rgb);
			    vec4 color = color_tex * color_base;
			    COLOR = vec4(color.rgb * color.a, color.a);
			}
			[/gdscript]
			[/codeblocks]
		</member>
		<member name="speed_scale" type="float" setter="set_speed_scale" getter="get_speed_scale" default="1.0">
			Specifies the playback speed of the currently held Live2D model.
		</member>
	</members>
	<signals>
		<signal name="motion_event">
			<param index="0" name="value" type="String" />
			<description>
				Called at the timing of the event time embedded in [i]Motion[/i].
				[b]Example:[/b]
				[codeblocks]
				[gdscript]
				func _on_motion_event(value: String):
				    print(value)

				func _ready():
				    $GDCubismUserModel.motion_event.connect(_on_motion_event)
				[/gdscript]
				[/codeblocks]
			</description>
		</signal>
		<signal name="motion_finished">
			<description>
				Called at the timing when _Motion_ has finished playing.
				[b]Example:[/b]
				[codeblocks]
				[gdscript]
					func _on_motion_finished(value: String):
					    print(value)

					func _ready():
					    $GDCubismUserModel.motion_event.connect(_on_motion_event)
				[/gdscript]
				[/codeblocks]
			</description>
		</signal>
	</signals>
	<constants>
		<constant name="CSM_MOC_VERSION_UNKNOWN" value="0" enum="moc3FileFormatVersion">
			Unknown or failed to load
		</constant>
		<constant name="CSM_MOC_VERSION_30" value="1" enum="moc3FileFormatVersion">
			moc3 file version from 3.0.00 to 3.2.07
		</constant>
		<constant name="CSM_MOC_VERSION_33" value="2" enum="moc3FileFormatVersion">
			moc3 file version from 3.3.00 to 3.3.03
		</constant>
		<constant name="CSM_MOC_VERSION_40" value="3" enum="moc3FileFormatVersion">
			moc3 file version from 4.0.00 to 4.1.05
		</constant>
		<constant name="CSM_MOC_VERSION_42" value="4" enum="moc3FileFormatVersion">
			moc3 file version from 4.2.00 to 4.2.02
		</constant>
		<constant name="CSM_MOC_VERSION_50" value="5" enum="moc3FileFormatVersion">
			moc3 file version 5.0.00 and above
		</constant>
		<constant name="PRIORITY_NONE" value="0" enum="Priority">
		</constant>
		<constant name="PRIORITY_IDLE" value="1" enum="Priority">
		</constant>
		<constant name="PRIORITY_NORMAL" value="2" enum="Priority">
		</constant>
		<constant name="PRIORITY_FORCE" value="3" enum="Priority">
		</constant>
		<constant name="FULL_PARAMETER" value="0" enum="ParameterMode">
			Specify this when playing the [i]Motion[/i] specified by the [method GDCubismUserModel.start_motion] function.
			When this is specified, operations by gd_cubism_parameter cannot be performed.
		</constant>
		<constant name="NONE_PARAMETER" value="1" enum="ParameterMode">
			Specify this when using the gd_cubism_parameter.adoc obtained by the [method GDCubismUserModel.get_parameters] function to operate the Live2D model.
			When this is specified, motion playback cannot be performed by the [method GDCubismUserModel.start_motion] function.
		</constant>
		<constant name="PHYSICS" value="0" enum="MotionProcessCallback">
			The animation update process is performed within the [code]_physics_process[/code] function. Use this when you want to interact with physical simulation.
		</constant>
		<constant name="IDLE" value="1" enum="MotionProcessCallback">
			The animation update process is performed within the [code]_process[/code] function.
		</constant>
		<constant name="MANUAL" value="2" enum="MotionProcessCallback">
			No animation update process is performed. To process the animation, use the [method GDCubismUserModel.advance] function.
			I hope this helps! If you have any other requests, feel free to ask.
		</constant>
	</constants>
</class>
